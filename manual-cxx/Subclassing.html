<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

  <head>
    <title>Subclassing - Panda3D Manual</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" href="style.css" type="text/css"><link rel="shortcut icon" href="favicon.ico">    <meta name="keywords" content="Panda3D, Panda, 3D, Python, graphics, free, game, engine, game rendering engine, simulation, open source, free download, Disney, ETC, Entertainment Technology Center, open-source">
    <meta name="description" content="Free open source 3D game and simulation engine developed by Disney and maintained by Carnegie Mellon University\'s Entertainment Technology Center">
    </head>
    <body>
<table width=960 cellpadding=0 cellspacing=0 id=main align=center>
<tr>
<td id=borderleft></td>
<td id=maincenter valign=top>
<tr><td id=pcontent valign=top><h2>Panda3D Manual: Subclassing</h2>
<div style="width:100%; padding: 1px;" class=subnavigation>
<table width="640px" cellpadding="0" cellspacing="0" border="0">
              <tr>
              <td width="70px" align="left">&nbsp;&nbsp;<a style="text-decoration:none" href="Threading.html"><img border=0 width=16 height=16 src="arrow_left.png" align=absmiddle> <u>Prev</u></a></td>
              <td width="70px" align="center"><a style="text-decoration:none" href="Main_Page.html"><img border=0 width=16 height=16 src="arrow_up.png" align=absmiddle><u>Top</u></a></td>
              <td width="70px" align="right"><a style="text-decoration:none" href="Table_of_features_supported_per_graphic_renderer.html"><u>Next</u> <img border=0 width=16 height=16 src="arrow_right.png" align=absmiddle></a>&nbsp;&nbsp;</td>
              </tr></table></div><div class='wikicontent' id='wikicontentid'><table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Subclassing.html#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="Subclassing.html#The_Theory"><span class="tocnumber">2</span> <span class="toctext">The Theory</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="Subclassing.html#The_Practice"><span class="tocnumber">3</span> <span class="toctext">The Practice</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="Subclassing.html#In_the_real_world"><span class="tocnumber">4</span> <span class="toctext">In the real world</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="Subclassing.html#Conclusion"><span class="tocnumber">5</span> <span class="toctext">Conclusion</span></a></li>
</ul>
</td></tr></table>
<h3> <span class="mw-headline" id="Introduction">Introduction</span></h3>
<p>Both Python and C++, being object-oriented programming languages, take advantage of the concept known as "Inheritance", to allow for a class to subclass one or more other classes. This allows for the creation of a sub-class (or descendent class) that is said to "inherit" all the attributes of the super class (or ancestor class), usually with the purpose of expanding upon them. 
</p><p>Subclassing pure-python classes from python or C++ classes from C++ is fairly straightforward and there's plenty of literature on the subject. The wikipedia article on <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Inheritance_(computer_science)">inheritance</a> is a good starting point before proceeding to the language-specific documentation. 
</p><p>Special care however must be taken when creating a Python class that subclasses from a C++ class, as there are limitations to it.
</p>
<h3> <span class="mw-headline" id="The_Theory">The Theory</span></h3>
<p>The C++ classes do not exactly exist in the Python namespace. They can't; they're C++ objects, not Python objects. Instead, for each C++ class that must be available through Python, a wrapper class that has the same name as the C++ class and all of the same methods has been created. When you call one of the methods on the Python wrapper, it turns around and calls the underlying C++ method of the same name. Thus, it looks like you're actually dealing directly with the C++ object, even though you're really dealing with a Python object.
</p><p>When you inherit from a C++ class, you are actually inheriting from the Python wrapper class. You can't actually inherit from the C++ class itself, since you're writing a Python class, not a C++ class.
</p><p>This means that whenever you create an instance of your new inherited class, you're creating an instance of the C++ class, the Python wrapper, and your Python inherited class. But then if you pass a pointer of your instance to some C++ method, all it receives is a pointer to the C++ class. 
</p><p>In the context of Panda, if you create an instance of a new "node" class and store it in the scene graph, you are really only storing the underlying C++ object in the scene graph--the Python part of the object gets left behind. This makes sense, because the C++ structures can only store pointers to C++ objects, not Python objects.
</p><p>So, when you pull the node out of the scene graph later, it creates a new Python wrapper around it and returns that new wrapper. Now all you have is the original C++ node--it's not your new node class any more, it's just the Python wrapper to the C++ class.
</p>
<h3> <span class="mw-headline" id="The_Practice">The Practice</span></h3>
<p>With most C++ classes the only way forward is to create a new C++ subclass and the related Python wrapper around it. However, there is a work-around for classes such as PandaNode and NodePath. Both these C++ classes have in fact been designed with functionality to store and retrieve python objects on them. Specifically, the methods <b>setPythonTag()</b>, <b>getPythonTag()</b> and <b>hasPythonTag()</b> are available to respectively store, retrieve and check for the existence of a pointer to an arbitrary python object on these C++ objects.
</p><p>This allows us to subclass from the Python wrapper class around the C++ object and store, on the C++ object, a pointer to the new sub class. 
</p><p>Let's first see an example of what <b>doesn't</b> work:
</p>
<pre class="python"><span style="color: #ff7700;font-weight:bold;">import</span> direct.<span style="color: black;">directbase</span>.<span style="color: black;">DirectStart</span><br /><span style="color: #ff7700;font-weight:bold;">from</span> panda3d.<span style="color: black;">core</span> <span style="color: #ff7700;font-weight:bold;">import</span> PandaNode<br />&#160;<br /><span style="color: #808080; font-style: italic;">## Here we define the new class, subclassing PandaNode</span><br /><span style="color: #808080; font-style: italic;">## and adding a new variable to it.</span><br /><span style="color: #ff7700;font-weight:bold;">class</span> MyNewNode<span style="color: black;">&#40;</span>PandaNode<span style="color: black;">&#41;</span>:<br />    <span style="color: #ff7700;font-weight:bold;">def</span> <span style="color: #0000cd;">__init__</span><span style="color: black;">&#40;</span><span style="color: #008000;">self</span>, aName<span style="color: black;">&#41;</span>:<br />        PandaNode.<span style="color: #0000cd;">__init__</span><span style="color: black;">&#40;</span><span style="color: #008000;">self</span>, aName<span style="color: black;">&#41;</span><br />        <span style="color: #008000;">self</span>.<span style="color: black;">aVariable</span> = <span style="color: #483d8b;">&quot;A value&quot;</span><br />&#160;<br /><span style="color: #808080; font-style: italic;">## Here we are creating a new node and we -think- </span><br /><span style="color: #808080; font-style: italic;">## we are placing it in the scene graph:</span><br />myNewNode = MyNewNode<span style="color: black;">&#40;</span><span style="color: #483d8b;">&quot;MyNewNode&quot;</span><span style="color: black;">&#41;</span><br />aNodePath = aspect2d.<span style="color: black;">attachNewNode</span><span style="color: black;">&#40;</span>myNewNode<span style="color: black;">&#41;</span><br />&#160;<br /><span style="color: #808080; font-style: italic;">## Here we -attempt- to fetch the stored variable,</span><br /><span style="color: #808080; font-style: italic;">## but we'll get an error because aNodePath.node()</span><br /><span style="color: #808080; font-style: italic;">## returns a PandaNode, not myNewNode!</span><br /><span style="color: #ff7700;font-weight:bold;">print</span><span style="color: black;">&#40;</span>aNodePath.<span style="color: black;">node</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span>.<span style="color: black;">aVariable</span><span style="color: black;">&#41;</span></pre>
<p>The workaround is for an instance of the new node class to store itself on the PandaNode, as a Python tag:
</p>
<pre class="python"><span style="color: #ff7700;font-weight:bold;">import</span> direct.<span style="color: black;">directbase</span>.<span style="color: black;">DirectStart</span><br /><span style="color: #ff7700;font-weight:bold;">from</span> panda3d.<span style="color: black;">core</span> <span style="color: #ff7700;font-weight:bold;">import</span> PandaNode<br />&#160;<br /><span style="color: #808080; font-style: italic;">## Here we define the new class, subclassing PandaNode</span><br /><span style="color: #808080; font-style: italic;">## storing its own instance as a python tag and </span><br /><span style="color: #808080; font-style: italic;">## initializing a new variable.</span><br /><span style="color: #ff7700;font-weight:bold;">class</span> MyNewNode<span style="color: black;">&#40;</span>PandaNode<span style="color: black;">&#41;</span>:<br />    <span style="color: #ff7700;font-weight:bold;">def</span> <span style="color: #0000cd;">__init__</span><span style="color: black;">&#40;</span><span style="color: #008000;">self</span>, aName<span style="color: black;">&#41;</span>:<br />        PandaNode.<span style="color: #0000cd;">__init__</span><span style="color: black;">&#40;</span><span style="color: #008000;">self</span>, aName<span style="color: black;">&#41;</span><br />        PandaNode.<span style="color: black;">setPythonTag</span><span style="color: black;">&#40;</span><span style="color: #008000;">self</span>, <span style="color: #483d8b;">&quot;subclass&quot;</span>, <span style="color: #008000;">self</span><span style="color: black;">&#41;</span><br />        <span style="color: #008000;">self</span>.<span style="color: black;">aVariable</span> = <span style="color: #483d8b;">&quot;A value&quot;</span><br />&#160;<br /><span style="color: #808080; font-style: italic;">## Here we create a new node and we are aware we are</span><br /><span style="color: #808080; font-style: italic;">## placing its -PandaNode- in the scene graph.</span><br />myNewNode = MyNewNode<span style="color: black;">&#40;</span><span style="color: #483d8b;">&quot;MyNewNode&quot;</span><span style="color: black;">&#41;</span><br />aNodePath = aspect2d.<span style="color: black;">attachNewNode</span><span style="color: black;">&#40;</span>myNewNode<span style="color: black;">&#41;</span><br />&#160;<br /><span style="color: #808080; font-style: italic;">## Now, first we fetch the panda node:</span><br />thePandaNode = aNodePath.<span style="color: black;">node</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span> <br />&#160;<br /><span style="color: #808080; font-style: italic;">## then we fetch the instance of MyNewNode stored on it:</span><br />theInstanceOfMyNewNode = thePandaNode.<span style="color: black;">getPythonTag</span><span style="color: black;">&#40;</span><span style="color: #483d8b;">&quot;subclass&quot;</span><span style="color: black;">&#41;</span><br />&#160;<br /><span style="color: #808080; font-style: italic;">## and finally we fetch the variable we were </span><br /><span style="color: #808080; font-style: italic;">## interested in all along:</span><br /><span style="color: #ff7700;font-weight:bold;">print</span><span style="color: black;">&#40;</span>theInstanceOfMyNewNode.<span style="color: black;">aVariable</span><span style="color: black;">&#41;</span></pre>
<h3> <span class="mw-headline" id="In_the_real_world">In the real world</span></h3>
<p>In a real-world scenario, while dealing with many nodes of arbitrary types, things get only marginally more difficult. Ultimately you'll want to access attributes that you know are present on nodes of one or more new subclasses. For this purpose, once you have a handle to the subclass instance, you can either test for the type you are expecting (safe but makes the application more static) or you can test for the presence of the attribute itself (less safe but creates potentially more dynamic, expandable application). 
</p><p>For example:
</p>
<pre class="python"><span style="color: #808080; font-style: italic;">## here we setup the scene</span><br />aNodePath = render.<span style="color: black;">attachNewNode</span><span style="color: black;">&#40;</span>anInstanceOfMyNewSubclass<span style="color: black;">&#41;</span><br />aPandaNode = aNodePath.<span style="color: black;">node</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span><br />&#160;<br /><span style="color: #808080; font-style: italic;">## here we loop over all nodes under render,  </span><br /><span style="color: #808080; font-style: italic;">## to find the one we are interested in:</span><br /><span style="color: #ff7700;font-weight:bold;">for</span> child <span style="color: #ff7700;font-weight:bold;">in</span> render.<span style="color: black;">getChildren</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span><br />    <span style="color: #ff7700;font-weight:bold;">if</span> child.<span style="color: black;">hasPythonTag</span><span style="color: black;">&#40;</span><span style="color: #483d8b;">&quot;subclass&quot;</span><span style="color: black;">&#41;</span>:<br />       theInstanceOfASubclass = child.<span style="color: black;">getPythonTag</span><span style="color: black;">&#40;</span><span style="color: #483d8b;">&quot;subclass&quot;</span><span style="color: black;">&#41;</span><br />&#160;<br />       <span style="color: #808080; font-style: italic;">## here we test for its type, which is safe</span><br />       <span style="color: #808080; font-style: italic;">## but doesn't catch subclasses of the subclass</span><br />       <span style="color: #808080; font-style: italic;">## or simply other objects that have the same</span><br />       <span style="color: #808080; font-style: italic;">## interface and would work just as well:</span><br />       <span style="color: #ff7700;font-weight:bold;">if</span> <span style="color: #008000;">type</span><span style="color: black;">&#40;</span>theInstanceOfASubclass <span style="color: black;">&#41;</span> == <span style="color: #008000;">type</span><span style="color: black;">&#40;</span>MyNewSubclass<span style="color: black;">&#41;</span>:<br />           theInstanceOfASubclass.<span style="color: black;">aVariable</span> = <span style="color: #483d8b;">&quot;a new value&quot;</span><br />           <span style="color: #ff7700;font-weight:bold;">continue</span><br />&#160;<br />       <span style="color: #808080; font-style: italic;">## here instead we test for the presence of an</span><br />       <span style="color: #808080; font-style: italic;">## attribute, which mean that all compatible  </span><br />       <span style="color: #808080; font-style: italic;">## objects get modified:</span><br />       <span style="color: #ff7700;font-weight:bold;">if</span> <span style="color: #008000;">hasattr</span><span style="color: black;">&#40;</span>theInstanceOfASubclass, <span style="color: #483d8b;">&quot;aVariable&quot;</span><span style="color: black;">&#41;</span>:<br />           theInstanceOfASubclass.<span style="color: black;">aVariable</span> = <span style="color: #483d8b;">&quot;a new value&quot;</span><br />           <span style="color: #ff7700;font-weight:bold;">continue</span></pre>
<h3> <span class="mw-headline" id="Conclusion">Conclusion</span></h3>
<p>In conclusion we might not be able to truly subclass a C++ class from Python, but we can certainly get very close to it. There is of course an overhead and these solutions should not be overused, resorting to pure C++ subclasses where performance is an issue. But where performance is not -as much- of an issue, you can probably get a lot of mileage following the examples provided above and expanding upon them.
</p>
<!-- 
NewPP limit report
Preprocessor node count: 45/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mw_manual:pcache:idhash:2321-0!*!*!!en!*!* and timestamp 20130413051546 -->
</div><div style="width:100%; padding: 1px;" class=subnavigation>
<table width="640px" cellpadding="0" cellspacing="0" border="0">
              <tr>
              <td width="70px" align="left">&nbsp;&nbsp;<a style="text-decoration:none" href="Threading.html"><img border=0 width=16 height=16 src="arrow_left.png" align=absmiddle> <u>Prev</u></a></td>
              <td width="70px" align="center"><a style="text-decoration:none" href="Main_Page.html"><img border=0 width=16 height=16 src="arrow_up.png" align=absmiddle><u>Top</u></a></td>
              <td width="70px" align="right"><a style="text-decoration:none" href="Table_of_features_supported_per_graphic_renderer.html"><u>Next</u> <img border=0 width=16 height=16 src="arrow_right.png" align=absmiddle></a>&nbsp;&nbsp;</td>
              </tr></table></div><div id=legal>&copy; Carnegie Mellon University 2010</div></td></tr></table></td><td id=borderright></td></tr></table></td><td id=borderright></td></tr></table></body></html>